what:
 initializing dynamic variables (so not constants) in the header of a subroutine
bad:
  INTEGER(LONG) :: J=0  ! a do loop variable (that changes)
good:
  INTEGER(LONG) :: J    ! a do loop
  J = 0
why:
  J is not reset using bad, so the next time you call the subroutine, you'll get the previous value.
  If J was a constant, then this would not be an issue.

-------------------------------------------------------------------------------------------------------------

what:
  define if a variable is constant or not
bad:
  INTEGER(LONG) :: A_VALUE=0  ! does something
good:
  INTEGER(LONG) :: A_VALUE=0  ! does something; constant
why:
  help address the previous issue
